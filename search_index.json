[
["index.html", "Introducción a R Capítulo 1 ¿Qué es R? 1.1 Prerrequisitos", " Introducción a R UNTDF Luciano Selzer 2016-08-23 Capítulo 1 ¿Qué es R? R es un lenguaje utilizado principalmente para realizar análisis estadísticos, gráficos y para programación. Es una implementación gratuita de S, que fue creado en los años 70 por cientficos en los laboratorios Bell de AT&amp;T. Debido a su licencia libre y relativa facilidad de uso gran cantidad de funciones estadísticas, de manejo de datos, gráficos han sido escritas. Al ser un lenguaje de programación las rutinas o scripts pueden ser compartidos y reutilizados por otros usuarios. Además, ya que todo el análisis estadístico queda documentado en el script permite reproducir los resultados obtenidos en una investigación de forma sencilla. Tiene un sistema de paquetes que permite distribuir de forma simple y rápida nuevas funcionalidades. Es actualmente el software que ofrece mayor número de funciones estadísticas y aplicaciones para la creación de gráficos. Colaboradores de todo el mundo producen paquetes destinados a resolver problemas particulares o desarrollan determinadas técnicas estadísticas. Cada usuario puede, además, crear sus propias funciones y rutinas combinando las funciones existentes. Existe una amplia comunidad de usuarios y por lo tanto, una gran oferta de ayudas para aquellos que se inician en el uso del programa, incluyendo foros de discusión en internet y una creciente bibliografía. R es una lingua franca para el intercambio de ideas en el ámbito científico. De la misma manera en que se escribe un artículo para comunicar ideas, pueden escribirse rutinas para comunicar un análisis. Un número creciente de trabajos citan este software o presentan rutinas escritas en este lenguaje publicadas. 1.1 Prerrequisitos Para este curso son necesarios una serie de programas. Primero, necesitamos R. Para bajarlo ir a https://cran.r-project.org/, hay varias opciones según el sistema operativo (Linux, Mac OS X, Windows). Elegir la opción correspondiente. Si eligen Windows, a continuación deben elegir base y luego Download R 3.3.1 for Windows que es la versión actual al momento de escribir estas palabras. Luego de que termine de bajar instalarlo. Por otro lado, necesitaremos Git. Git es un sistema de control de versión. En el próximo capítulo veremos como se usa. Los sistemas de control de versión sirven para mantener un control de los cambios en el código, respaldo, y facilitan la colaboración entre pares. Para descargarlo ir https://git-scm.com/. Abajo a la derecha aparecerá una imagen de un monitor con un botón donde aparece la versión para nuestro sistema operativo. Hacer click ahí, descargar e instalar. A continuación debemos instalar RStudio. Para esto, debemos navegar hasta https://www.rstudio.com/products/rstudio/download2/ y descargar el la versión gratuita de escritorio (RStudio Desktop). Instalarla. Una vez que RStudio está instalado solo falta configurar Git. Solo hace falta decirle la ruta del ejecutable. Para esto hay que abrir RStudio e ir al menú Tools\\Global Options y luego ir a Git\\SVN, el anteúltimo icono. Si utilizaron la instalación por defecto de Git la ruta es C:\\Program Files\\Git\\bin si tienen Windows 32 bits o C:\\Program Files (x86)\\Git\\bin si tienen Windows 64 bits. La carpeta Program Files puede llamarse Archivos de Programa si tienen Windows en español. Presionar Ok. Finalmente, pueden crear un usuario en GitHub. Es un servicion gratuito. Ir a https://github.com/ y completar el formulario con usuario, correo electrónico y contraseña. Presionar Sign Up for GitHub. Si no están en una computadora compartida, también será conveniente crear un par de claves pública y privada para no tener que autenticarse cada vez que quieran subir sus cambios a GitHub. En Rstudio: 1. Vayan a Tools\\Global Options..., luego a la pestaña de Git\\SVN. 2. Ahí deben hacer click en create RSA key. Pueden poner una Passphase que es como una contraseña, no es obligatoria pero hará que las claves sean más seguras. 3. Presionan Create, les va a aparecer un cartel y ponen Ok. 4. Luego, presionan en View public key. Copian la clave. En el sitio web de Github: En la esquina superior derecha hay un icono que es su foto de usuario. Hacen click ahí y luego en Settings. Van la pestaña SSH and GPG keys. Luego, presionan en New SHH Key. En Title ponen el nombre del programa que lo va a usar. RStudio en nuestro caso. En Key pegan lo que han copiado de RStudio. Finalmente, presionan Add SSH Key Con todo esto ya instalado y configurado ¡ya están listos para empezar! "],
["intro.html", "Capítulo 2 Introdución 2.1 Introducción a RStudio 2.2 Flujo de trabajo con RStudio 2.3 Introducción a R 2.4 R como calculadora 2.5 Funciones matemáticas 2.6 Comparando cosas 2.7 Variables y asignación 2.8 Vectorización 2.9 Manejando el entorno 2.10 Paquetes R 2.10 Challenge 1 2.10 Solution to challenge 1 2.10 Challenge 2 2.10 Solution to challenge 2 2.10 Challenge 3 2.10 Solution to challenge 3 2.10 Challenge 4 2.10 Solution to challenge 4 2.10 Challenge 5 2.10 Solution to challenge 5", " Capítulo 2 Introdución Trabajar con la interfaz de gráfica de R es un poco incómodo (poniendolo suavemente). Por lo que se han desarrollado varios entornos de desarrollo integrado (IDE por sus siglas en inglés) que facilitan su uso. Una de las más trabajadas y pulidas es RStudio. 2.1 Introducción a RStudio RStudio es una interfaz de desarrollo integrada, gratis y de código abierto. Posee un editor de código, funciona en múltiples plataformas (incluyendo servidores) y tiene muchas ventajas como integración con control de versión y manejo de proyectos. Disposición Básica Cuando abres RStudio por primera vez verás tres paneles: La consola interactiva de R (a la izquierda) El Entorno/Historial, en inglés Environment/History (en pestañas en la parte superior derecha) Archivos/Gráficos/Paquetes/Ayuda/Visualizador, también en inglés Files/Plots/Packages/Help/Viewer (en la parte inferior derecha) Una vez que abre un archivo, como por ejemplo un script de R, un panel de edición se abre en la parte superior izquierda. 2.2 Flujo de trabajo con RStudio Hay dos maneras básicas de trabajar con RStudio. Probar y jugar dentro de la consola interactiva y luego copiar el código a un archivo .R para ejecutar más tarde. Funciona bien cuando se hacen pequeñas pruebas y recién se comienza. Pero rápidamente se vuelve laborioso. Empezar a escribir un archivo .R y luego usar el comando / atajo de RStudio para ejecutar la línea actual o las líneas seleccionadas en la consola. Es la mejor forma de empezar; así todo el código queda guardado para más tarde Podrás ejecutar el archivo desde RStudio o usando la función de R source(). Tip: Ejecutando partes de tu código RStudio tiene una gran flexibilidad al ejecutar código dentro de la ventana de edición. Hay botones, menues y atajos de teclado. Para ejectuar la línea actual podés 1. hacer click en el botón Run arriba del panel de edición, o 2. Seleccionar “Run Lines” desde el menú “Code”, o 3. apretar Ctrl+Enter en Windows o Linux o Command+Enter en OS X (Este atajo también puede verse dejando el puntero del mouse sobre el botón Run). Para ejecutar un bloque de código, seleccionálo y después solo presiona Run. Si has modificado una parte del bloque que has ejecutado reción no hay necesidad de reseleccionarlo y darle Run, podés usar el botón a continuación, Re-run the previous region. Esto va a ejecutar el bloque de código previo incluyendo las modificaciones que has hecho. 2.3 Introducción a R Una gran parte del tiempo en R se pasa en la consola interactiva. Ahí es donde se corre el código y puede ser un entorno útil para probar ideas antes de escribirlas en un script de R. La consola de RStudio es la misma que si ejecutasen R en la linea de comando o la interfaz gráfica de R (R-GUI). Cada vez que abran la consola van a ver un montón de información y abajo aparece un signo mayor “&gt;” seguido de un cursor parpadeante. Opera en la forma como cualquier otra línea de comando. REPL por sus siglas en inglés: Read, evaluate, print, loop. Leer, evaluar, imprimir, buclear. Uno ingresa órdenes o comandos, R trata de ejecutarlos y luego imprime el resultado. Aunque a veces algunas funciones no imprimen nada. 2.4 R como calculadora Lo más simple que se puede hacer con R es aritmética: 1 + 100 [1] 101 Y R va a impirmir la respuesta, precedida por un “[1]”. No se preocupen por esto ahora, lo vamos a ver más adelante. Por ahora piensen que está indicando la salida. Si introducen un comando de forma incompleta, R va esperar que lo terminen 1 + + Cada vez que apriten Enter y la consola muestre un “+” en vez de “&gt;”, es que está esperando que terminen el comando. Si quieren cancelar el comando solo hay que presionar “Esc” y la consola volverá a mostrar el prompt “&gt;”. Tip: Cancelando comandos Si estás usando R desde la linea de comando en vez de dentro de RStudio, hay que presionar Ctrl+C en vez de Esc para cancelar el comando. Esto también se aplica a usuarios de Mac también. Cancelar un comando no es útil solamente para anular comandos incompletos: también podés cancelar una computación que R está ejecutando (por ejemplo, si está tomando demasiado tiempo), o para eliminar el código que estás escribiendo actualmente. Cuando se usa R como calculadora, el orden las operaciones es el mismo que aprendieron en la escuela. De mayor a menor precedencia: Paréntesis: (, ) Exponentes: ^ o ** División: / Multiplicación: * Adición: + Substracción: - 3 + 5 * 2 ## [1] 13 Usa paréntesis para agrupar operaciones de manera de forzar el orden de evaluación si difiera de la por defecto, o para aclarar cual es tu intención. (3 + 5) * 2 ## [1] 16 Puede volverse pesado si se usa cuando no se necesita, pero a veces clarifica tus intenciones. Recuerda que otros podrían leer tu código. (3 + (5 * (2 ^ 2))) # difícil de leer 3 + 5 * 2 ^ 2 # claro, si recordás las reglas 3 + 5 * (2 ^ 2) # si olvidás algunas reglas esto puede ayudar. El texto después de cada linea de código es llamado “comentario”. Cualquier cosa que este después del símbolo numeral o hash (#) es ignorado por R cuando ejecuta el código. Los números muy grandes o pequeños se imprimen en notación científica: 2/10000 ## [1] 2e-04 que es una abreviatura de multiplicar por 10^XX“. Por lo que 2e-4 es una abreviatura de 2 * 10^(-4). Uno mismo puede entrar números en notación científica: 5e3 #No hay menos aquí ## [1] 5000 2.5 Funciones matemáticas R tiene muchas funciones matemáticas incorporadas. Para llamar una función simplemente escribimos su nombre, seguido por paréntesis de apertura y cierre. Cualquier cosa dentro de los paréntesis es llamado argumentos de la función: sin(1) # funciones trigonométricas ## [1] 0.841471 log(1) # logaritmo natural ## [1] 0 log10(10) # logaritmo en base 10 ## [1] 1 exp(0.5) # e^(1/2) ## [1] 1.648721 No se preocupen por recordar todas las funciones en R. Se pueden buscar en Google, o si recuerdan como comienza el nombre de la función, pueden presionar la tecla Tab para usar la función de autocompletado de RStudio. Esta es una de las ventajas de RStudio sobre R solo, tiene la función de autocompletar que permiten que sea más fácil buscar funciones, sus argumentos, y los valores que pueden tomar. Escribiendo un signo de pregunta ? antes del nombre la funcion abrirá la página de ayuda de esa función. Además de mostrar una descripción detallada de la misma, sus argumentos, y los valores que devuelve, al final de la página hay ejemplos que muestran brevemente como se puede usar la función. 2.6 Comparando cosas También podemos hacer comparaciones en R: 1 == 1 # igualdad (notar que son dos signos igual, se lee como &quot;es igual a&quot;) ## [1] TRUE 1 != 2 # desiguldad (leer como &quot;no es igual a&quot;) ## [1] TRUE 1 &lt; 2 # menor que ## [1] TRUE 1 &lt;= 1 # menor que o igual que ## [1] TRUE 1 &gt; 0 # mayor que ## [1] TRUE 1 &gt;= -9 # mayor que o igual que ## [1] TRUE Tip: Comparando números Un advertencia acerca de la comparación de números: nunca usar == para comparar dos números a menos que sean integers (un tipo de data que se usa para representar números enteros específicamente). Las computadoras solo pueden representar números decimales con un cierto grado de precisión. Por lo que dos números que cuando son impresos por R se ven iguales, pueden tener representaciones subyacentes diferentes y por lo tanto ser diferentes por un pequeño margen de error (llamado Machine numeric tolerance) En su lugar, deberías usar la función all.equal Para más información, leer: http://floating-point-gui.de/ 2.7 Variables y asignación Podemos guardar los valores en variales usando el operador de asignación &lt;-, de esta forma: x &lt;- 1/40 Notá que cuando se asigna no se imprime el valor. En cambio, lo almacenamos para después en algo llamado variable. Ahora xcontiene el valor 0.025: x ## [1] 0.025 Más precisamente, el valor guardado es una aproximanción decimal a esta fracción llamado número de coma flotante. Mirá en las pestaña Environment en los paneles de RStudio, y ahí verás quex y su valor han aparecido. Nuestra variable x puede ser usada en lugar de un número en cualquiear cálculo donde se espere un número: log(x) ## [1] -3.688879 Las variables también pueden ser reasignadas: x &lt;- 100 x tenía el valor 0.025 y ahora tiene el valor 100. La asignación de valores puede contener la variable que esta siendo asignada: x &lt;- x + 1 # notar como RStudio actualiza la descrición de x en la pestaña Environment La parte derecha de la asignación puede ser cualquier expresión válida de R. La parte derecha es evaluada completamente antes de que la asignación ocurra. Los nombres de la variables pueden contener letras, números, guiones bajos y puntos. No pueden empezar con un número ni pueden contener espacioes. Distintas personas usan distintas convenciones para nombrar variables con nombres largos, incluidos: puntos.entre.palabras guiones_bajos_entre_palabras camelCaseParaSepararPalabras Cual usar es una decisión individual (o del proyecto), pero hay que ser consistente También se puede usar el símbolo =para asignar x = 1/40 Pero esto es mucho menos común entre los usuarios de R. Lo más es importante es ser consistente con el operador que uses. Ocasionalmente, hay lugares donde es menos confuso usar &lt;- que =, y es el símbolo más usado en la comunidad. Por lo que la recomendación es usar &lt;-. Además, en Rstudio hay un atajo de teclado para insertar la asignación: hay que presionar Alt+-. 2.8 Vectorización Una consideración final de lo que hay estar atento es que R está vectorizado, lo que significa que las variables y funciones pueden tener vectores como valores. Por ejemplo: 1:5 ## [1] 1 2 3 4 5 2^(1:5) ## [1] 2 4 8 16 32 x &lt;- 1:5 2^x ## [1] 2 4 8 16 32 Esto es muy poderoso; lo vamos a discutir en profundidad más adelante. 2.9 Manejando el entorno Hay algunas funciones muy útiles para interactuar con la sesión de R. ls listará todas los objetos (funciones y variables) almacenados en el entorno global (tu sesión de trabajo en R) Tip: objetos ocultos ls ocultará cualquier objeto cuyo nombre empiece con un punto “.” por defecto. Para listar todos los objetos, hay que tipear ls(all.names=TRUE). Notar que aquí no le dimos ningún argumento a ls, pero igual necesitamos usar los paréntesis para decirle a R que llame a la función. ls ## function (name, pos = -1L, envir = as.environment(pos), all.names = FALSE, ## pattern, sorted = TRUE) ## { ## if (!missing(name)) { ## pos &lt;- tryCatch(name, error = function(e) e) ## if (inherits(pos, &quot;error&quot;)) { ## name &lt;- substitute(name) ## if (!is.character(name)) ## name &lt;- deparse(name) ## warning(gettextf(&quot;%s converted to character string&quot;, ## sQuote(name)), domain = NA) ## pos &lt;- name ## } ## } ## all.names &lt;- .Internal(ls(envir, all.names, sorted)) ## if (!missing(pattern)) { ## if ((ll &lt;- length(grep(&quot;[&quot;, pattern, fixed = TRUE))) &amp;&amp; ## ll != length(grep(&quot;]&quot;, pattern, fixed = TRUE))) { ## if (pattern == &quot;[&quot;) { ## pattern &lt;- &quot;\\\\[&quot; ## warning(&quot;replaced regular expression pattern &#39;[&#39; by &#39;\\\\\\\\[&#39;&quot;) ## } ## else if (length(grep(&quot;[^\\\\\\\\]\\\\[&lt;-&quot;, pattern))) { ## pattern &lt;- sub(&quot;\\\\[&lt;-&quot;, &quot;\\\\\\\\\\\\[&lt;-&quot;, pattern) ## warning(&quot;replaced &#39;[&lt;-&#39; by &#39;\\\\\\\\[&lt;-&#39; in regular expression pattern&quot;) ## } ## } ## grep(pattern, all.names, value = TRUE) ## } ## else all.names ## } ## &lt;bytecode: 0x36cf630&gt; ## &lt;environment: namespace:base&gt; Podés usar rm para eliminar objetos que no sean necesarios: rm(x) Si tenés muchos objetos en tu entorno y querés borrar todos ellos, podés pasar el resultado de ls como argumento de la función rm: rm(list = ls()) En este caso hemos combinado las dos. Como en el orden de las operaciones, cualquier cosa dentro de los paréntesis es evaluada primero. En este caso hemos especificado que el resultado de ls sea usado por el argumento list en rm. Cuando asignamos valores a argumentos por nombre, ¡hay que usar el operardor =! Si en cambio se usa &lt;-, podrían haber efectos secundarios no intencionales, o un mensaje de error: rm(list &lt;- ls()) ## Error in rm(list &lt;- ls()): ... must contain names or character strings Tip: Warnings vs Errors ¡Presten atención cuando R hace algo inesperado! R tira errores, como el de arriba, cuando no puede proceder con un cálculo. Los Warnings (advertencias) por otro lado generalmente significa que la función se ejecutó, pero que probablemente no ha funcionado como se esperaba. En ambos casos, el mensaje que imprime R generalmente contiene pista de como arreglar el problema. Aunque a veces pueden ser algo crípticos y requieran cierta experiencia saber que es lo que está pasando. 2.10 Paquetes R Los paquetes de R son colecciones de funciones o a veces datos, que son justamente empaquetadas. Los paquetes añaden funciones que no están presentes en R. Al momento de la escritura haya más de 8500 paquetes en CRAN (the comprehensive R archive network). Y muchos más en otros repositorios como GitHub. R y RStudio tienen funcionalidades para manejar los paquetes Para ver que paquetes están instalados tipear: installed.packages() Para instalar paquetes tipear install.packages(&quot;packagename&quot;), donde packagename es el nombre del paquete, entre comillas. Para actualizar los paquetes instalados, tipear update.packages() Para eliminar un paquete tipear remove.packages(&quot;packagename&quot;) Para usar un paquete en la sesión actual tipear library(packagename) 2.10 Challenge 1 Which of the following are valid R variable names? min_height max.height _age .mass MaxLength min-length 2widths celsius2kelvin {: .r} 2.10 Solution to challenge 1 The following can be used as R variables: min_height max.height MaxLength celsius2kelvin {: .r} The following creates a hidden variable: .mass {: .r} The following will not be able to be used to create a variable _age min-length 2widths {: .r} {: .solution} {: .challenge} 2.10 Challenge 2 What will be the value of each variable after each statement in the following program? mass &lt;- 47.5 age &lt;- 122 mass &lt;- mass * 2.3 age &lt;- age - 20 {: .r} 2.10 Solution to challenge 2 mass &lt;- 47.5 {: .r} This will give a value of 47.5 for the variable mass age &lt;- 122 {: .r} This will give a value of 122 for the variable age mass &lt;- mass * 2.3 {: .r} This will multiply the existing value of 47.5 by 2.3 to give a new value of 109.25 to the variable mass. age &lt;- age - 20 {: .r} This will subtract 20 from the existing value of 122 to give a new value of 102 to the variable age. {: .solution} {: .challenge} 2.10 Challenge 3 Run the code from the previous challenge, and write a command to compare mass to age. Is mass larger than age? 2.10 Solution to challenge 3 One way of answering this question in R is to use the &gt; to set up the following: mass &gt; age {: .r} [1] TRUE {: .output} This should yield a boolean value of TRUE since 109.25 is greater than 102. {: .solution} {: .challenge} 2.10 Challenge 4 Clean up your working environment by deleting the mass and age variables. 2.10 Solution to challenge 4 We can use the rm command to accomplish this task rm(age, mass) {: .r} {: .solution} {: .challenge} 2.10 Challenge 5 Install the following packages: ggplot2, plyr, gapminder 2.10 Solution to challenge 5 We can use the install.packages() command to install the required packages. We can also install them in one go like so: install.packages(c(&quot;ggplot2&quot;, &quot;plyr&quot;, &quot;gapminder&quot;)) {: .r} {: .solution} {: .challenge} "],
["proyectos.html", "Capítulo 3 Manejo de Proyectos con RStudio 3.1 Introducción 3.2 Una posible solución 3.3 Buenas prácticas para manejo de proyectos 3.4 Tratar los datos como solo lectura 3.5 Limpieza de datos 3.6 Trata la salida generada como descartable 3.7 Breve Introducción a Git", " Capítulo 3 Manejo de Proyectos con RStudio 3.1 Introducción El proceso científico es naturalmente incremental, y muchos proyectos empiezan como algunas notas, algo de código, luego un manuscrito y eventualmente todo queda mezclado. Managing your projects in a reproducible fashion doesn’t just make your science reproducible, it makes your life easier. — Vince Buffalo ((???)) April 15, 2013 La mayoría de la gente organiza sus proyectos así: Hay muchas razones por las cuales SIEMPRE deberían evitar esto: Es muy dificil cual es la versión original de tus datos y cual es la modificada; Se vuelve un lío porque mezcla archivos de varias extensiones juntos; Probablemente te tomará mucho tiempo encontrar el archivo que realmente buscas, y ver cuales son las figuras correctas y cual es el código que las genera; Un buen diseño de proyecto va a ser tu vida más fácil: Te va a ayudar a mantener la integridad de tus datos; Va a ser que sea más sencillo compartir tu código con alguien más (Un compañero de laboratorio, colaborador, o supervisor); Te permite subir fácilmente código con tu propuesta de manuscrito; Hace que sea más fácil volver a un proyecto luego de dejarlo por un tiempo. 3.2 Una posible solución Afortunadamente, hay herramientas y paquetes que pueden ayudarte a manejar el trabajo de forma efectiva. Una de los aspectos más poderosos y útiles de RStudio es el manejo de proyectos. Hoy vamos a usarlo para crear un proyecto auto-contenido y reproducible. Desafio: Crear un proyecto autocontenido Vamos a crear un proyecto auto-contenido en RStudio: Hacer clic en “File” en el menú, y luego en “New Project” Click en “New Directory” Click en “Empty Project” Escribir el nombre de la carpeta donde se guardará el proyecto, e.g. “mi_proyecto” Asegurarse de que la casilla “Create a git repository” este seleccionada. Click en el botón “Create Project” Ahora cuando iniciemos R en la carpeta del proyecto, o abramos el proyecto con RStudio, todo nuestro trabajo en este proyecto va estar auto-contenido en esta carpeta 3.3 Buenas prácticas para manejo de proyectos Aunque no hay una manera que sea la “mejor” para diseñar un proyecto, si hay alguno lineamientos principales a seguir que harán el manejo de proyecto más sencillo: 3.4 Tratar los datos como solo lectura Esta es probablemente la meta más importante al configurar un proyecto. Generalmente, los datos toman mucho tiempo o son caros de obtener. Al trabajar con ellos interactivamente (e.g. en Excel) donde pueden ser modificados, significa que nunca estás seguro de donde vienen los datos, o como han sido modificados desde su colección. Por es buena idea tratar los datos como “solo-lectura” 3.5 Limpieza de datos En muchos casos los datos estarán “sucios”: es necesarios un pre-procesado significativo para que sean aceptados por R (o cualquier otro lenguaje de programación). Esto a veces es llamado “data munging”. Es útil guardar estos scripts en una carpeta separada, y crear una segunda carpeta de datos “solo lectura” para guardar los datos “limpios”. 3.6 Trata la salida generada como descartable Cualquier cosa generada por tus scripts debe ser tratado como descartable: debería poder ser regenerada a partir de tus scripts. Hay muchas formas de manejar estas salidas. Es útil tener un carpeta de salida con diferentes sub-carpetas para cada análisis. Esto hace que sea más fácil encontrar los resultados, como muchos de los análisis son exploratorios y no terminan usándose en el proyecto final, y algunos de los análisis se comparten entre proyectos. Tip: Prácticas suficientemente buenas para la computación científica Good Enough Practices for Scientific Computing da las siguientes recomendaciones para la organización de proyectos: Poner cada proyecto en su propia carpeta, la cual tiene el nombre del proyecto. Poner los documentos de texto asociados con el proyecto una carpeta llamada doc. Poner los datos “crudos” en una carpeta llamada data, y los archivos generados durante la limpieza en una carpeta llamada results. Poner el código de fuente del proyecto y los programas en la carpeta scr y programas externos o compilados localmente en la carpeta bin. Nombrar todos los archivos de forma que refleje su contenido o función. Tip: ProjectTemplate - una posible solución Una forma de automatizar el manejo de proyectos es instalar un paquete de terceros, ProjectTemplate. Este paquete va a configurar una estructura ideal para el manejo del proyecto. Es muy útil ya que permite tener el análisis de manera estructurada y organizada. En conjunto con la funcionalidad propia de RStudio y Git vas a poder mantener un seguimiento de tu trabajo y ser capaz de compartirlo con colaboradores. Instala ProjectTemplate. Carga el paquete. Inicializa el proyecto: r install.packages(&quot;ProjectTemplate&quot;) library(ProjectTemplate) create.project(&quot;../my_project&quot;, merge.strategy = &quot;allow.non.conflict&quot;) Para más información de ProjectTemplate y sus funcionalidades vista el sitio web ProjectTemplate. ## Separa la definición de la función de su aplicación Cuando el proyecto en nuevo, los archivos script generalmente contienen muchas líneas de código que es ejecutado directamente. Cuando madura, los pedazos reusables son convertidos en funciones. Es buena idea separar estas funciones en un carpeta distinta; una carpeta para las funciones útiles que vas a reusar entre análisis y proyectos y otra para guardar los scripts de análisis. &lt;div class=&quot;callout&quot;&gt; &lt;h2 id=&quot;tip-evita-la-duplicacion&quot;&gt;Tip: evita la duplicación&lt;/h2&gt; &lt;p&gt;Puede que te encuentres usando datos o scripts de análisis entre varios proyectos. Generalmente, vas a querer evitar la duplicación para ahorrar espacio y evitar hacer cambios al código en varios lugares.&lt;/p&gt; &lt;p&gt;En este caso es útil hacer &amp;quot;vínculos símbolicos&amp;quot;, basicamente son atajos a archivos que están en otro lugar del sistema de archivos. En Linux y OS x se usar comando &lt;code&gt;ln -s&lt;/code&gt;, y en Windows se puede crear un acceso directo o usar el comando &lt;code&gt;mklink&lt;/code&gt; en la terminal de Windows.&lt;/p&gt; &lt;/div&gt; ## Guarda los datos en la carpeta data Ahora que tenemos una buena estructura de carpetas, vamos a guardar el archivo de datos en la carpeta `data/`. &lt;div class=&quot;challenge&quot;&gt; &lt;h2 id=&quot;desafio-1&quot;&gt;Desafio 1&lt;/h2&gt; &lt;p&gt;Descarga los datos de gapminder de &lt;a href=&quot;https://raw.githubusercontent.com/resbaz/r-novice-gapminder-files/master/data/gapminder-FiveYearData.csv&quot;&gt;aquí&lt;/a&gt;.&lt;/p&gt; &lt;ol style=&quot;list-style-type: decimal&quot;&gt; &lt;li&gt;Descarga el archivo (CTRL + S, click botón derecho -&amp;gt; &amp;quot;Guardar como&amp;quot;, o Archivo -&amp;gt; &amp;quot;Guardar página como&amp;quot;)&lt;/li&gt; &lt;li&gt;Asegúrate que el archivo guardado tiene el nombre &lt;code&gt;gapminder-FiveYearData.csv&lt;/code&gt;.&lt;/li&gt; &lt;li&gt;Guarda el archivo en la carpeta &lt;code&gt;data/&lt;/code&gt; dentro de tu proyecto.&lt;/li&gt; &lt;/ol&gt; &lt;p&gt;Más tarde vamos a cargar e inspeccionar estos datos.&lt;/p&gt; &lt;/div&gt; ## Control de Versión También hemos configurado nuestro proyecto para que se integre con git, poniendolo bajo control de versión. RStudio tiene una buena interfaz a git que la consola, pero es muy limitada por lo que a veces será necesario usar la consola. Vamos a hacer confirmación (*commit*) inicial de nuestros archivos. El panel de &quot;Environment/History&quot;&quot; también tiene el panel de &quot;Git&quot;. Podemos hacer un *stage* de cada archivo marcando la casilla al lado: Vas a ver una &quot;A&quot; verde al lado de los archivos y carpetas preparados, y signos de pregunta amarillos al lado de los archivos y carpetas que git no está siguiendo. RStudio también muestra la diferencia entre los archivos en las diferentes confirmaciones. &lt;div class=&quot;callout&quot;&gt; &lt;h2 id=&quot;tip-versionando-salida-descartable&quot;&gt;Tip: versionando salida descartable&lt;/h2&gt; &lt;p&gt;En general no querés versionar las salidas descartable (o los datos de solo lectura). Hay que modificar el archivo &lt;code&gt;.gitignore&lt;/code&gt; para decirle que ignore estos archivos y carpetas.&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;challenge&quot;&gt; &lt;h2 id=&quot;desafio-2&quot;&gt;Desafio 2&lt;/h2&gt; &lt;ol style=&quot;list-style-type: decimal&quot;&gt; &lt;li&gt;Crea una carpeta dentro del proyecto llamada &lt;code&gt;graphs&lt;/code&gt;.&lt;/li&gt; &lt;li&gt;Modifica el archivo &lt;code&gt;.gitignore&lt;/code&gt; para que contenga &lt;code&gt;graphs&lt;/code&gt; para que estas salidas descartables no sean versionadas.&lt;/li&gt; &lt;/ol&gt; &lt;/div&gt; &gt;&lt;div class=&quot;solution&quot;&gt; &gt;&lt;p&gt;## Solución al Desafio 3&lt;/p&gt; &gt;&lt;p&gt;Esto puede ser logrado con la linea de comando: &amp;gt; $ mkdir graphs &amp;gt; $ echo &amp;quot;graphs/&amp;quot; &amp;gt;&amp;gt; .gitignore&lt;/p&gt; &gt;&lt;/div&gt; 3.7 Breve Introducción a Git El control de versión es un sistema que permite hacer backups de nuestro código y colaborar con otras personas de forma simple. Los primeros sistemas de versionado datan de 1980. Desde entonces han sido mejorados en gran medida. Uno de los sistemas más populares es Git. En git, cada versión puede pensarse como una foto instantánea de los archivos y carpetas en ese momento. Cuando inicializamos git este crea una carpeta .git en nuestra carpeta de trabajo, dentro de esa carpeta hay una base de datos donde guarda esas instantáneas. Los archivos en git pueden tener dos estados básicos: con seguimiento y sin seguimiento. Un archivo sin seguimiento no está dentro de git y por lo tanto no sabe si ha sido modificado. En cambio, un archivo que esta siendo seguido, git puede saber que ha cambiado desde la última vez fue “confirmado”. Para que sea seguido el archivo, primero debemos añadirlo (add). En RStudio, basta con marcar la casilla al lado del archivo. Los archivos marcados pasarán a tener una A verde. Y pasan a lo como area de preparación (staging area) y se dicen que están preparados. Cuando confirmamos (commit) los archivos que estaban en preparación pasan a ser parte de la instantánea dentro de git. En cada confirmación debemos poner un mensaje corto, menos de 50 caracteres. El mensaje debe ser lo más descriptivo posible para saber que hemos cambiado. Además del mensaje, podemos incluir una descripción más larga. Luego el ciclo se repite cada vez que modifiquemos los archivos. Es una buena práctica hacer solo un commit por archivo modificado, a menos que las modificaciones esten relacionadas. Por otro lado, podemos tener git en un servidor remoto. De forma que otros colaboradores puedan trabajar en el proyecto al mismo tiempo. Primero debemos subir los cambios que hicimos. Para configurar el servidor remoto debemos entrar en el shell. Y escribir: git remote add origin git@github.com:EstadisticaUNTDF/test.git Con esto estamos diciendo a git que añada un servidor remoto llamado origin y a continuación le damos la URL. git remote Con este comando vemos cuales son nuestros servidores remotos. Y al utilizar el botón de flecha verde (Push) en la pestaña de Git, enviamos nuestros cambios al servidor. Supongamos ahora que un colaborador ha estado trabajando en el código y ha subido sus cambios al repositorio remoto. Para obtener el nuevo código e integrarlo en nuestra versión local debemos hacer clic en la flecha azul hacia abajo. De esta forma bajamos las últimas confirmaciones y las fusionamos con nuestro trabajo en caso que no haya conflictos. "],
["como-obtener-ayuda.html", "Capítulo 4 ¿Cómo obtener ayuda? 4.1 Archivos de ayuda 4.2 Operadores Especiales 4.3 Ayuda de paquetes 4.4 Si solo recordas una parte de la función 4.5 Si no tenés idea donde empezar 4.6 Cuando tu código no funciona: obtener ayuda de tus pares 4.7 Otras fuentes de ayuda", " Capítulo 4 ¿Cómo obtener ayuda? 4.1 Archivos de ayuda Toda función de R tiene su página de ayuda. Hay varias formas de llegar a ellas. Dos de ellas consiste en escribir el signo de pregunta (?) seguido del nombre completo de la función. La otra en escribir help() y el nombre de la función ?function_name help(function_name) Esto muestra la página de ayuda como html en RStudio, o como texto plano en R. Cada página está dividida de la siguiente manera: Título: una breve descripción de la función Description: Una descripción un poco más amplia de lo que hace la función. Usage: muestra los argumentos que acepta la función. Arguments: listado de los argumentos, que significa cada unos y que tipo de valores acepta Details: detalles importantes de los que hay que tener en cuenta. Value: que tipo de datos devuelve la función. See also: otras funciones relacionadas que quizá sean útiles para el trabajo que estamos realizando. Examples: ejemplos de uso de la función. Otras funciones pueden tener otras secciones, pero estas son las más importantes. Además, las 4 primeras secciones son obligatorias si desarrollamos nuestro paquete. Tip: Leer la ayuda Uno de los aspectos más impresionantes de R es el gran número de funciones. Por lo que es imposible acordarse de todas y como se usan. Por suerte, el tener páginas de ayuda tan detalladas significa que ¡no hace falta recordar todo! 4.2 Operadores Especiales Para obtener ayuda para operadores especiales hay que usarlos entre comillas. ?&quot;+&quot; 4.3 Ayuda de paquetes Muchos paquetes vienen con “vignettes”: son tutoriales o documentación de ejemplo extendida. Sin ningún argumente vignette() listará todas las vignettes de todos los paquetes instalados; si especificamos el paquete, i.e. vignette(package=&quot;package-name&quot;), nos dará un listado de la vignettes disponibles para package-name, y vignette(&quot;vignette-name&quot;) abrirá la vignette especificada. 4.4 Si solo recordas una parte de la función Si no estás seguro en que paquete está la función, o como se escribe podés hacer una búsqueda difusa: ??function_name 4.5 Si no tenés idea donde empezar Si no sabés que función o paquete usar CRAN Task Views es una lista de paquetes agrupados en distintos campos de aplicación. Puede ser un buen punto de comienzo. 4.6 Cuando tu código no funciona: obtener ayuda de tus pares Si tenés problemas usando una función, 9 de cada 10 veces, otros han tenido el mismo problema y han sido respondidas en Stack Overflow. Podés buscar usando el tag [r]. También podés buscar en la lista de correo R-Help-es. Si no podés encontrar la respuesta, hay que preguntarla e incluir un ejemplo reproducible de nuestro problema. Es muy importante incluirlo, ya que aumenta en varios ordenes de magnitud la probabilidad y velocidad de respuesta. Para incluir datos, la forma más sencilla (si los datos no son demasiados) es usar la función dput: ?dput Va a crear un volcado de los datos con los que estás trabajando, de forma que puedan ser copiados y pegados en la consola de cualquira que quiera ayudar. Otro punto importante a incluir es el código de lo que hemos intentado hacer. Está muy mal visto preguntar “¿Cómo hago esto?” sin mostrar que hemos intentado resolverlo nosotros. Al menos incluir las respuestas relacionadas a nuestra pregunta y porque no nos sirven. sessionInfo() ## R version 3.3.1 (2016-06-21) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: Ubuntu precise (12.04.5 LTS) ## ## locale: ## [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C ## [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 ## [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 ## [7] LC_PAPER=en_US.UTF-8 LC_NAME=C ## [9] LC_ADDRESS=C LC_TELEPHONE=C ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C ## ## attached base packages: ## [1] stats graphics grDevices utils datasets base ## ## loaded via a namespace (and not attached): ## [1] Rcpp_0.12.6 bookdown_0.1.5 digest_0.6.10 mime_0.5 ## [5] R6_2.1.2 xtable_1.8-2 formatR_1.4 magrittr_1.5 ## [9] evaluate_0.9 stringi_1.1.1 miniUI_0.1.1 rstudioapi_0.6 ## [13] rmarkdown_1.0 tools_3.3.1 stringr_1.0.0 shiny_0.13.2 ## [17] yaml_2.1.13 httpuv_1.3.3 htmltools_0.3.5 knitr_1.14 ## [21] methods_3.3.1 Imprime en la consola la versión actual de R y también los paquetes que hemos cargado. Esto puede ser muy útil para ayudar a reproducir y solucionar nuestros problemas. Desafio 1 Lee la ayuda para la función c() ¿Qué clase de vector esperas crear si ejecutas los siguientes comandos?: c(1, 2, 3) c(&#39;d&#39;, &#39;e&#39;, &#39;f&#39;) c(1, 2, &#39;f&#39;)` ``` Desafio 2 Examina la página de ayuda de paste(). Vas a usarla más adelante. ¿Cuál es la diferencia entre los argumentos sepy collapse? Desafio 3 Usa la ayuda para encontrar una función (y sus argumentos) con la cual podrías cargar datos de un archivo csv en el cual las columnas están delimitadas con “” (tabulación) y el punto decimal es un “.” (punto). Esta comprobación del punto decimal es importante, porque en otros paises se usa la coma como separador decimal. Pista: usa ??csv para buscar funciones relacionadas con csv. 4.7 Otras fuentes de ayuda Quick R RStudio cheat sheets Cookbook for R "],
["estructura-de-datos.html", "Capítulo 5 Estructura de Datos 5.1 Tipos de datos 5.2 Vectores y Coerción de Tipo 5.3 Data Frames 5.4 Factores 5.4 Solution to Challenge 2 5.5 Listas 5.6 Solución al Desafio 3 5.7 Matrices 5.7 Solución al Desafio 4 5.8 Solución al Desafio 5 5.9 Solucion al Desafio 6", " Capítulo 5 Estructura de Datos Una de las características más poderosa de R es la habilidad de leer datos tabulares – como la que podrías tener en una hoja de cállculo o CSV. Empecemos por hacer un set datos de prueba en la carpeta data/, llamada datos-felinos.csv. pelaje,peso,gusta_ovillo atigrado,2.1,1 negro,5.0,0 bicolor,3.2,1 Tip: Editando archivos de texto en R Alternativamente, podés crear data/datos-felinos.csv usando un editor de texto (Bloc de Notas, Nano) o con RStudio usando la opción File -&gt; New File -&gt; Text File. Podemos cargarlo en R usando la siguiente función: gatos &lt;- read.csv(file = &quot;data/datos-felinos.csv&quot;) gatos ## pelaje peso gusta_ovillo ## 1 atigrado 2.1 TRUE ## 2 negro 5.0 FALSE ## 3 bicolor 3.2 TRUE La función read.csv se usa para leer datos tabulares almacenados como texto donde la columnas de datos están delimitadas por comas (CSV = comma separated values). Si guardamos el archivos con Excel con configuración regional en español o similar, probablmente el archivo no sea un archivo CSV legal. En este caso las comas se usan como punto decimal, entonces se usa “;” como separador de columnas. La función read.csv2 tiene en cuenta está distinción. Otro delimitador común de columnas es la tabulación, si los datos están en este formato hay que usar la función read.delim. Si los datos están separados con otro caracter se puede usar la función read.table que es más general y flexible. Podemos empezar a exploar nuestro set de datos enseguida, seleccionando columnas con el operador $: gatos$peso ## [1] 2.1 5.0 3.2 gatos$pelaje ## [1] atigrado negro bicolor ## Levels: atigrado bicolor negro Se pueden hacer otras operaciones con las columnas: ## Digamos que descubrimos que los pesos tienen un kilo de menos: gatos$peso + 1 ## [1] 3.1 6.0 4.2 paste(&quot;Mi gato es&quot;, gatos$pelaje) ## [1] &quot;Mi gato es atigrado&quot; &quot;Mi gato es negro&quot; &quot;Mi gato es bicolor&quot; Pero que pasa si hacemos esto: gatos$peso + gatos$pelaje ## Warning in Ops.factor(gatos$peso, gatos$pelaje): &#39;+&#39; not meaningful for ## factors ## [1] NA NA NA Entender los tipos básicos de datos es fundamental para entender como funciona R. 5.1 Tipos de datos Si adivinaste que el último comando devuelve un error porque sumar 2.1 y negro no tiene sentido, estás en lo correcto - y ya tenés una intuición importante de un concepto de programación llamado tipo de dato. Podemos ver que tipo de dato es cierto objeto con: typeof(gatos$peso) ## [1] &quot;double&quot; Hay 5 tipos básicos de dato: double, integer, complex, logical y character. typeof(3.14) ## [1] &quot;double&quot; typeof(1L) ## [1] &quot;integer&quot; typeof(1 + 1i) ## [1] &quot;complex&quot; typeof(TRUE) ## [1] &quot;logical&quot; typeof(&#39;banana&#39;) ## [1] &quot;character&quot; Note que el sufijo L para marcar que el número es un integer. Sin importar que tan complicado sea nuestro analisis todos los datos en R son interpretado como uno de esos tipos básicos. Y ese rigor tiene consecuencias importantes. Otro usuario a añadido datos de otro gato. La información está en el archivo data/feline-data_v2.csv. file.show(&quot;data/datos_felinos_v2.csv&quot;) pelaje,peso,gusta_ovillo atigrado,2.1,TRUE negro,5.0,FALSE bicolor,3.2,TRUE bicolor,2.3 o 2.4,TRUE Cargamos de nuevo los datos como antes, y chequeamos que tipo de dato encontramos en la columna peso: gatos &lt;- read.csv(file = &quot;data/datos_felinos_v2.csv&quot;) typeof(gatos$peso) ## [1] &quot;integer&quot; Ahora nuestros pesos ya no son de tipo doble. Si intentamos hacer la misma operación matemática que antes vamos a tener problemas: gatos$peso + 1 ## Warning in Ops.factor(gatos$peso, 1): &#39;+&#39; not meaningful for factors ## [1] NA NA NA NA ¿Qué ha sucedido? CUando R lee un archivo, insiste en que todo en una columna tiene que ser del msimo tipo básico. Si no puede entender que todo en la columna es tipo doble, entonces nadie en la columna tiene tipo doble. La tabla cargada en nuestro ejemplo de datos es llamada data.frame y es nuestro primer ejemplo de algo llamado estructura de datos - que significa, una estrucutura que R sabe construir a partir de tipos de datos básicos. Podemos ver que es una data.frae llamando la función class en el objecto: class(gatos) ## [1] &quot;data.frame&quot; Para usar existosamente nuestros datos en R, primero necesitamos entender que son los tipos básicos de estructuras y como se comportan. Por ahora quitemos la última linea de nuestros gatos y recarguemos el archivo, mientras investigamos más este comportamiento. datos-felinos.csv: pelaje,peso,gusta_ovillo atigrado,2.1,1 negro,5.0,0 bicolor,3.2,1 Y devuelta en RStudio gatos &lt;- read.csv(file=&quot;data/datos-felinos.csv&quot;) 5.2 Vectores y Coerción de Tipo Para entender mejor este comportamiento, conozcamos otro tipo de estructura de datos: el vector mi_vector &lt;- vector(length = 3) mi_vector ## [1] FALSE FALSE FALSE Un vector en R es basicamente una lista ordenada de cosas, con la condición especial que todo en el vector deber ser del mismo tipo básico. Si no elegis el tipo de dato, por defecto selecciona logical; o lo podés declarar como un vector vacío o cualquier otro tipo que quieras. otro_vector &lt;- vector(mode = &#39;character&#39;, length = 3) otro_vector ## [1] &quot;&quot; &quot;&quot; &quot;&quot; Podés ver si un objecto es un vector: str(otro_vector) ## chr [1:3] &quot;&quot; &quot;&quot; &quot;&quot; La salida algo críptica de este comando indica el tipo básico de dato en este vector - en este caso chr, caracter; un indicador del númer de cosas en ese vector, en este caso [1:3]; y unos ejemplos de que hay en el vector - en este caso una cadena de caracteres vacia. De forma similar si hacemos: str(gatos$peso) ## Factor w/ 4 levels &quot;2.1&quot;,&quot;2.3 o 2.4&quot;,..: 1 4 3 2 Vemos que también es un vector - las columnas de datos que cargamos en el data.frame de R son todos vectores, y es por eso que R fuerza toda la columna en ser de un mismo tipo básico de dato. Discusión 1 ¿Por qué R es tán dogmático sobre lo que ponemos en nuestras columnas de datos? ¿Cómo esto nos ayuda? Al tener todos los datos de la columna como un solo tipo nos permite hacer algunas suposiciones simples sobre ellos; si podes interpretar una entrada como un número, entonces podés interpetar todos las entradas como números, entonces no tenemos que comprobar cada una. Esta consistencia, como la consistencia de usar el mismo separador en nuestros archivos, es lo que se refiere a datos limpios. A la larga, esa consistencia estricta nos facilita mucho nuestro trabajo con R. También podes hacer vectores con contenidos explicitos usando la función de concatenación concat_vector &lt;- c(2,6,3) concat_vector ## [1] 2 6 3 Dado lo que ya hemos aprendido ¿Qué tipo de vector piensa que va a proudcir lo siguiente? quiz_vector &lt;- c(2,6,&#39;3&#39;) Esto es algo llamado coerción de tipo, y es la fuente de muchas sorpresas y la razón por la que tenemos que estar atentos de los tipos básicos de datos y como R va a interpretarlos. Cuando R encuentra un mezcla de tipos (númericos y caracter en este ejemplo) para ser combinados en un solo vector, va a forzar todos al mismo tipo. Considera lo siguiente: coercion_vector &lt;- c(&#39;a&#39;, TRUE) coercion_vector ## [1] &quot;a&quot; &quot;TRUE&quot; otro_coercion_vector &lt;- c(0, TRUE) otro_coercion_vector ## [1] 0 1 Los reglas de coerción son: logical -&gt; integer -&gt; numeric -&gt; complex -&gt; character, donde -&gt; es leido como es *transofrmado en Podes intertar forzar la coerción contra este flujo usando las funciones as. character_vector_ejemplo &lt;- c(&#39;0&#39;,&#39;2&#39;,&#39;4&#39;) character_vector_ejemplo ## [1] &quot;0&quot; &quot;2&quot; &quot;4&quot; character_coerced_to_numeric &lt;- as.numeric(character_vector_ejemplo) character_coerced_to_numeric ## [1] 0 2 4 numeric_coerced_to_logical &lt;- as.logical(character_coerced_to_numeric) numeric_coerced_to_logical ## [1] FALSE TRUE TRUE Como podés ver, ¡algunas cosas sorprendentes sucedes cuando R fuerza un tipo básico de dato en otro! Dejando el meollo de la coerción de tipos de lado, el punto es: si tus datos no se ven como pensabas que iban a verse, la coerción de tipos probablemente sea la culpable; asegurate que todo es del mismo tipo en tus vectores y las columnas de las data.frames, o vas a tener algunas sorpresas feas. Pero la coerción de tipos también puede ser ¡muy útil! Por ejemplo, en nuestros ejemplo de gatos los datos de gusta_ovillo es númerico, pero sabemos que los ceros y unos representan FALSE y TRUE (una forma común de representarlos). Deberiamos usar el tipo logical aquí, el cual tiene dos estados: TRUE o FALSE, que es exactamente lo que nuestros datos representa. Podemos coercionar esa columna a logical usando la función as.logical: gatos$gusta_ovillo ## [1] TRUE FALSE TRUE TRUE gatos$gusta_ovillo &lt;- as.logical(gatos$gusta_ovillo) gatos$gusta_ovillo ## [1] TRUE FALSE TRUE TRUE Concatenear también puede adjuntar cosas a un vector existente: ab_vector &lt;- c(&#39;a&#39;, &#39;b&#39;) ab_vector ## [1] &quot;a&quot; &quot;b&quot; concat_example &lt;- c(ab_vector, &#39;SWC&#39;) concat_example ## [1] &quot;a&quot; &quot;b&quot; &quot;SWC&quot; También se pueden hacer series de números mySeries &lt;- 1:10 mySeries ## [1] 1 2 3 4 5 6 7 8 9 10 seq(10) ## [1] 1 2 3 4 5 6 7 8 9 10 seq(1,10, by = 0.1) ## [1] 1.0 1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8 1.9 2.0 2.1 2.2 2.3 ## [15] 2.4 2.5 2.6 2.7 2.8 2.9 3.0 3.1 3.2 3.3 3.4 3.5 3.6 3.7 ## [29] 3.8 3.9 4.0 4.1 4.2 4.3 4.4 4.5 4.6 4.7 4.8 4.9 5.0 5.1 ## [43] 5.2 5.3 5.4 5.5 5.6 5.7 5.8 5.9 6.0 6.1 6.2 6.3 6.4 6.5 ## [57] 6.6 6.7 6.8 6.9 7.0 7.1 7.2 7.3 7.4 7.5 7.6 7.7 7.8 7.9 ## [71] 8.0 8.1 8.2 8.3 8.4 8.5 8.6 8.7 8.8 8.9 9.0 9.1 9.2 9.3 ## [85] 9.4 9.5 9.6 9.7 9.8 9.9 10.0 Podemos ver otras cosas sobre los vectores sequence_example &lt;- seq(10) head(sequence_example, n = 2) ## [1] 1 2 tail(sequence_example, n = 4) ## [1] 7 8 9 10 length(sequence_example) ## [1] 10 class(sequence_example) ## [1] &quot;integer&quot; typeof(sequence_example) ## [1] &quot;integer&quot; Finalmente, podes darle nombres a los elementos de vector: names_example &lt;- 5:8 names(names_example) &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;) names_example ## a b c d ## 5 6 7 8 names(names_example) ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; Desafio 1 Empieza haciendo un vector de 1 hasta 26. Multiplica el vector por 2, y dale al vector resultante nombres desde de la A hasta la Z (pista: hay un vector incluido llamado LETTERS). 5.3 Data Frames Dijimos que las columnas en el data.frame son vectores: str(gatos$peso) ## Factor w/ 4 levels &quot;2.1&quot;,&quot;2.3 o 2.4&quot;,..: 1 4 3 2 str(gatos$gusta_ovillo) ## logi [1:4] TRUE FALSE TRUE TRUE These make sense. But what about str(gatos$pelaje) ## Factor w/ 3 levels &quot;atigrado&quot;,&quot;bicolor&quot;,..: 1 3 2 2 5.4 Factores Otra estructura de datos importante son los llamados factores. Los factores generalmente se ven como datos tipo caracter, pero son usado tipicamente para representar información categórica. Por ejemplo, hagamos un vector de cadena nombrando los colores de los gatos para todos los gatos en el estudio: pelajes &lt;- c(&#39;atigrado&#39;, &#39;carey&#39;, &#39;carey&#39;, &#39;negro&#39;, &#39;atigrado&#39;) pelajes ## [1] &quot;atigrado&quot; &quot;carey&quot; &quot;carey&quot; &quot;negro&quot; &quot;atigrado&quot; str(pelajes) ## chr [1:5] &quot;atigrado&quot; &quot;carey&quot; &quot;carey&quot; &quot;negro&quot; &quot;atigrado&quot; Podemos convertir nuestro vector en factor así: Categorias &lt;- factor(pelajes) class(Categorias) ## [1] &quot;factor&quot; str(Categorias) ## Factor w/ 3 levels &quot;atigrado&quot;,&quot;carey&quot;,..: 1 2 2 3 1 Ahora R se ha dado cuenta que hay tres posibles categorias en nuestros datos - pero también hizo algo sorprendente; en vez de imprimir las cadenas que le dimos, obtuvimos un montón de números. R ha reemplazado nuestra categorias facilmente interpretables por nosotros con indices númericos debajo del capot. typeof(pelajes) ## [1] &quot;character&quot; typeof(Categorias) ## [1] &quot;integer&quot; Desafio 2 ¿Hay algún factor en nuestro data.frame gatos?¿Cuál es su nombre? Intenta usar ?read.csv para averiguar como mantener el texto como vector caracter en vez de factores; luego escribe un comando o dos para mostrar que el factor en gatos es en verdad un vector caracter cuando es cargo de estas forma. 5.4 Solution to Challenge 2 gatos &lt;- read.csv(file=&quot;data/feline-data.csv&quot;, stringsAsFactors=FALSE) str(gatos$coat) Note: new students find the help files difficult to understand; make sure to let them know that this is typical, and encourage them to take their best guess based on semantic meaning, even if they aren’t sure. En las funciones modeladoras, es importante saber cuales son los niveles de base. Se asume que es el primer factor, pero por defecto los factores son etiquetados en orden alfabético. Podes cambiar esto especificando los niveles: mydata &lt;- c(&quot;case&quot;, &quot;control&quot;, &quot;control&quot;, &quot;case&quot;) factor_ordering_example &lt;- factor(mydata, levels = c(&quot;control&quot;, &quot;case&quot;)) str(factor_ordering_example) ## Factor w/ 2 levels &quot;control&quot;,&quot;case&quot;: 2 1 1 2 En este caso, le hemos explicitado a R que “control” debería ser representado por 1, y “case” por 2. Esta designación es muy importante al interpretar los resultados de los modelos estadísticos. 5.5 Listas Otra estructura de datos que querrás en tu manga será la list (lista). Una lista tiene menos restricciones que otras estructuras, porque podés poner cualquier cosa en ella: list_example &lt;- list(1, &quot;a&quot;, TRUE, 1 + 4i) list_example ## [[1]] ## [1] 1 ## ## [[2]] ## [1] &quot;a&quot; ## ## [[3]] ## [1] TRUE ## ## [[4]] ## [1] 1+4i another_list &lt;- list(title = &quot;Research Bazaar&quot;, numbers = 1:10, data = TRUE ) another_list ## $title ## [1] &quot;Research Bazaar&quot; ## ## $numbers ## [1] 1 2 3 4 5 6 7 8 9 10 ## ## $data ## [1] TRUE Ahora podemos entender algo sorprendente de nuestra data.frame; ¿que sucede si ejecutamos?: typeof(gatos) ## [1] &quot;list&quot; Vemos que las data.frames se ven como listas “debajo del capot” - esto es porque en realidad un data.frame es una lista de vectores y factores - para lograr contener esas columnas que son una mezcla de vectores y factores, la data.frame necesita algo más flexible que un vector para poner todas las columnas en una tabla común. En otras palabras, data.frame es una lista especial en la cual todos los vectores tienen que tener la misma longitud. En nuestro ejemplo gatos, tenemos una variable integer, una double y una logical. Como hemos visto ya, cada columna del data.frame es un vector gatos$pelaje ## [1] atigrado negro bicolor bicolor ## Levels: atigrado bicolor negro gatos[,1] ## [1] atigrado negro bicolor bicolor ## Levels: atigrado bicolor negro typeof(gatos[,1]) ## [1] &quot;integer&quot; str(gatos[,1]) ## Factor w/ 3 levels &quot;atigrado&quot;,&quot;bicolor&quot;,..: 1 3 2 2 Cada columna es una observación de cada tipo de variable, por si misma una data.frame, y por lo tanto puede estar compuesta de elementos de diferentes tipos. gatos[1,] ## pelaje peso gusta_ovillo ## 1 atigrado 2.1 TRUE typeof(gatos[1,]) ## [1] &quot;list&quot; str(gatos[1,]) ## &#39;data.frame&#39;: 1 obs. of 3 variables: ## $ pelaje : Factor w/ 3 levels &quot;atigrado&quot;,&quot;bicolor&quot;,..: 1 ## $ peso : Factor w/ 4 levels &quot;2.1&quot;,&quot;2.3 o 2.4&quot;,..: 1 ## $ gusta_ovillo: logi TRUE Desafio 3 Hay varios formas sutilmente diferentes para llamar a las variables: gatos[1] gatos[[1]] gatos$pelaje gatos[“pelaje”] gatos[1, 1] gatos[, 1] gatos[1, ] Pista : Usa la función typeof() para examinar que se devuelve en cada caso. 5.6 Solución al Desafio 3 gatos[1] ## pelaje ## 1 atigrado ## 2 negro ## 3 bicolor ## 4 bicolor Podemos pensar que la data.frame es una lista de vectores. Un corchete simple [1] devuelve la primer rebanda de la lista de vectores, como otra lista. En este caso la primera columna del data.frame. gatos[[1]] ## [1] atigrado negro bicolor bicolor ## Levels: atigrado bicolor negro Los corchetes dobles [[1]] devuelven el contenido del item de la lista. En este caso los contenidos de la primera columna, un vector de tipo factor. gatos$pelaje ## [1] atigrado negro bicolor bicolor ## Levels: atigrado bicolor negro Este ejemplo usa el signo $ para llamar a los items por su nombre. pelaje es la primera columna de la data.frame, un vector de tipo factor. gatos[&quot;pelaje&quot;] ## pelaje ## 1 atigrado ## 2 negro ## 3 bicolor ## 4 bicolor Aquí usamos el corchete simple [&quot;pelaje&quot;] reemplazando el número de indice con el nombre de la columna. Como en el primer ejemplo, el objeto que devuelve es una lista list gatos[1, 1] ## [1] atigrado ## Levels: atigrado bicolor negro Este ejemplo usa un corchete simple, pero esta vez damos el valor de fila y columna. El objeto que se devuelve es el valor de la fila 1 y columna. El objeto es integer porque es parte de un vector de tipo factor, R muestra la etiqueta “atigrado” gatos[, 1] ## [1] atigrado negro bicolor bicolor ## Levels: atigrado bicolor negro Como en el ejemplo anterior usamos corchetes simples y proveemos las coordenadas de fila y columna. La fila no está especificada, R interpreta este valor ausente como todo los valores del este vector columna. gatos[1, ] ## pelaje peso gusta_ovillo ## 1 atigrado 2.1 TRUE De nuevo usamos el corchete simple con las coordenadas de fila y columa. La columna no está especificada. Se devuelve una lista que contiene todos los valores de la primer columna. 5.7 Matrices Último pero no menos está la matriz. Podemos declarar una matriz llena de ceros: matrix_example &lt;- matrix(0, ncol = 6, nrow = 3) matrix_example ## [,1] [,2] [,3] [,4] [,5] [,6] ## [1,] 0 0 0 0 0 0 ## [2,] 0 0 0 0 0 0 ## [3,] 0 0 0 0 0 0 Y como en otras estructuras de datos, podemos preguntar cosas sobre nuestra matriz: class(matrix_example) ## [1] &quot;matrix&quot; typeof(matrix_example) ## [1] &quot;double&quot; str(matrix_example) ## num [1:3, 1:6] 0 0 0 0 0 0 0 0 0 0 ... dim(matrix_example) ## [1] 3 6 nrow(matrix_example) ## [1] 3 ncol(matrix_example) ## [1] 6 Desafio 4 ¿Cual crees que será el resultado de length(matrix_example)? Prueba el código. ¿Estabas en lo correcto?¿Por qué? 5.7 Solución al Desafio 4 ¿Cuál crees que será el resultado de length(matrix_example)? matrix_example &lt;- matrix(0, ncol = 6, nrow = 3) length(matrix_example) ## [1] 18 Porque la matriz es un vector con el añadido de atributos de dimension, length te da el número total de elementos dentro de la matriz. Desafio 5 Crea otra matriz, esta vez que contenga los numeros de 1 a 50, con 5 columnas y 10 filas. ¿Cómo lleno la función matrix la matriz? ¿Por columnas o por filas? ¿Cuál es su opción por defecto? Fijate si podés averiguar como cambiar esto (pista: lee la documentación de matrix). 5.8 Solución al Desafio 5 x &lt;- matrix(1:50, ncol=5, nrow=10) x &lt;- matrix(1:50, ncol=5, nrow=10, byrow = TRUE) # to fill by row Desafio 6 Crea una lista de longitud 2 que contenga un vector caracter para cada parte de lo que hemos visto Data types Data structures Llena cada vector con los nombres de los tipos de datos y las estructuras de datos que hemos visto hasta ahora. 5.9 Solucion al Desafio 6 dataTypes &lt;- c(&#39;double&#39;, &#39;complex&#39;, &#39;integer&#39;, &#39;character&#39;, &#39;logical&#39;) dataStructures &lt;- c(&#39;data.frame&#39;, &#39;vector&#39;, &#39;factor&#39;, &#39;list&#39;, &#39;matrix&#39;) answer &lt;- list(dataTypes, dataStructures) Desafio 7 Considera la salida de R de la siguiente matriz: [,1] [,2] [1,] 4 1 [2,] 9 5 [3,] 10 7 ¿Cual fue el comando que se uso para crearla? Examina cada comando e intenta pensar cual es el correcto antes de tipearlos. Piensa en que tipo de matriz producirá cada uno. matrix(c(4, 1, 9, 5, 10, 7), nrow = 3) matrix(c(4, 9, 10, 1, 5, 7), ncol = 2, byrow = TRUE) matrix(c(4, 9, 10, 1, 5, 7), nrow = 2) matrix(c(4, 1, 9, 5, 10, 7), ncol = 2, byrow = TRUE) En este curso se va introducir al alumno en el manejo de R, con enfásis en investigación reproducible. "]
]
